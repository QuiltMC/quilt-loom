From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: zml <zml@stellardrift.ca>
Date: Sun, 8 Jan 2023 21:44:14 -0800
Subject: [PATCH] Fix interface injection of inner class interfaces


diff --git a/src/main/java/net/fabricmc/loom/configuration/ifaceinject/InterfaceInjectionProcessor.java b/src/main/java/net/fabricmc/loom/configuration/ifaceinject/InterfaceInjectionProcessor.java
index 363ea0c70a83b67e253abb6073b82613a1bd2ce0..af80470079ae06ae09d04e797dd873bdd5099bb6 100644
--- a/src/main/java/net/fabricmc/loom/configuration/ifaceinject/InterfaceInjectionProcessor.java
+++ b/src/main/java/net/fabricmc/loom/configuration/ifaceinject/InterfaceInjectionProcessor.java
@@ -28,6 +28,7 @@ import java.io.IOException;
 import java.nio.file.Path;
 import java.util.ArrayList;
 import java.util.Collections;
+import java.util.HashSet;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
@@ -44,6 +45,7 @@ import org.jetbrains.annotations.Nullable;
 import org.objectweb.asm.ClassReader;
 import org.objectweb.asm.ClassVisitor;
 import org.objectweb.asm.ClassWriter;
+import org.objectweb.asm.Opcodes;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -60,6 +62,7 @@ import net.fabricmc.mappingio.tree.MemoryMappingTree;
 
 public abstract class InterfaceInjectionProcessor implements MinecraftJarProcessor<InterfaceInjectionProcessor.Spec> {
 	private static final Logger LOGGER = LoggerFactory.getLogger(InterfaceInjectionProcessor.class);
+	private static final int INTERFACE_ACCESS = Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC | Opcodes.ACC_ABSTRACT | Opcodes.ACC_INTERFACE;
 
 	private final String name;
 	private final boolean fromDependencies;
@@ -173,14 +176,18 @@ public abstract class InterfaceInjectionProcessor implements MinecraftJarProcess
 	}
 
 	private static String appendComment(String comment, List<InjectedInterface> injectedInterfaces) {
+		final StringBuilder commentBuilder = comment == null ? new StringBuilder() : new StringBuilder(comment);
+
 		for (InjectedInterface injectedInterface : injectedInterfaces) {
-			String iiComment = "Interface {@link %s} injected by mod %s".formatted(injectedInterface.ifaceName.substring(injectedInterface.ifaceName.lastIndexOf("/") + 1), injectedInterface.modId);
+			String iiComment = "<p>Interface {@link %s} injected by mod %s</p>".formatted(injectedInterface.ifaceName.replace('/', '.').replace('$', '.'), injectedInterface.modId);
 
-			if (comment == null || !comment.contains(iiComment)) {
-				if (comment == null) {
-					comment = iiComment;
+			if (commentBuilder.indexOf(iiComment) == -1) {
+				if (commentBuilder.isEmpty()) {
+					commentBuilder.append(iiComment);
 				} else {
-					comment += "\n" + iiComment;
+					commentBuilder
+							.append('\n')
+							.append(iiComment);
 				}
 			}
 		}
@@ -222,6 +229,7 @@ public abstract class InterfaceInjectionProcessor implements MinecraftJarProcess
 
 	private static class InjectingClassVisitor extends ClassVisitor {
 		private final List<InjectedInterface> injectedInterfaces;
+		private final Set<String> knownInnerClasses = new HashSet<>();
 
 		InjectingClassVisitor(int asmVersion, ClassWriter writer, List<InjectedInterface> injectedInterfaces) {
 			super(asmVersion, writer);
@@ -254,5 +262,53 @@ public abstract class InterfaceInjectionProcessor implements MinecraftJarProcess
 
 			super.visit(version, access, name, signature, superName, modifiedInterfaces.toArray(new String[0]));
 		}
+
+		@Override
+		public void visitInnerClass(final String name, final String outerName, final String innerName, final int access) {
+			this.knownInnerClasses.add(name);
+			super.visitInnerClass(name, outerName, innerName, access);
+		}
+
+		@Override
+		public void visitEnd() {
+			// inject any necessary inner class entries
+			// this may produce technically incorrect bytecode cuz we don't know the actual access flags for inner class entries
+			// but it's hopefully enough to quiet some IDE errors
+			for (final InjectedInterface itf : injectedInterfaces) {
+				if (this.knownInnerClasses.contains(itf.ifaceName())) {
+					continue;
+				}
+
+				int simpleNameIdx = itf.ifaceName().lastIndexOf('/');
+				final String simpleName = simpleNameIdx == -1 ? itf.ifaceName() : itf.ifaceName().substring(simpleNameIdx + 1);
+				int lastIdx = -1;
+				int dollarIdx = -1;
+
+				// Iterate through inner class entries starting from outermost to innermost
+				while ((dollarIdx = simpleName.indexOf('$', dollarIdx + 1)) != -1) {
+					if (dollarIdx - lastIdx == 1) {
+						continue;
+					}
+
+					// Emit the inner class entry from this to the last one
+					if (lastIdx != -1) {
+						final String outerName = itf.ifaceName().substring(0, simpleNameIdx + 1 + lastIdx);
+						final String innerName = simpleName.substring(lastIdx + 1, dollarIdx);
+						super.visitInnerClass(outerName + '$' + innerName, outerName, innerName, INTERFACE_ACCESS);
+					}
+
+					lastIdx = dollarIdx;
+				}
+
+				// If we have a trailer to append
+				if (lastIdx != -1 && lastIdx != simpleName.length()) {
+					final String outerName = itf.ifaceName().substring(0, simpleNameIdx + 1 + lastIdx);
+					final String innerName = simpleName.substring(lastIdx + 1);
+					super.visitInnerClass(outerName + '$' + innerName, outerName, innerName, INTERFACE_ACCESS);
+				}
+			}
+
+			super.visitEnd();
+		}
 	}
 }
